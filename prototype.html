<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>キーボード不要コードエディタ (ローカル実行版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* 基本的なフォント設定など */
        body {
            font-family: sans-serif; /* Tailwindが設定しますが念のため */
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* Appコンポーネントのスタイルに合わせる */
        }
        #root {
            height: 100%;
            width: 100%;
        }
        /* スクロールバーのスタイル（オプション）*/
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Simple replacements for Lucide icons (using emojis or text)
        const ChevronRight = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>&gt;</span>;
        const MessageSquare = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>💬</span>;
        const Edit3 = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>✏️</span>;
        const CheckSquare = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>☑️</span>;
        const Square = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>⬜</span>;
        const Save = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>💾</span>;
        const Send = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>➢</span>;
        const Bot = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>🤖</span>;
        const User = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>👤</span>;
        const AlertTriangle = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>⚠️</span>;
        // PlusCircle, Trash2, Settings are not directly used in the final UI logic based on your provided React code.

        // --- React Component Code (from your provided script) ---
        // Renamed React imports to avoid conflict with global React from CDN
        const { useState, useEffect, useRef } = React;

        // Firebase imports are commented out as they are not used in local setup without config
        // import { initializeApp } from 'firebase/app';
        // import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
        // import { getFirestore, doc, setDoc, getDoc, collection, addDoc, onSnapshot, query, where, updateDoc, deleteDoc } from 'firebase/firestore';

        // const firebaseConfig = {};
        // const appId = 'default-app-id';
        // const initialAuthToken = null;

        const App = () => {
          const [currentScreen, setCurrentScreen] = useState('chat'); // 'chat' or 'editor'
          const [chatMessages, setChatMessages] = useState([
            { sender: 'gemini', text: 'こんにちは！どのようなコードを作成しますか？または、既存のコードを編集しますか？', isCodeSuggestion: false }
          ]);
          const [code, setCode] = useState('');
          const [selectedLines, setSelectedLines] = useState([]);
          const [userInput, setUserInput] = useState('');
          const [editingContext, setEditingContext] = useState(null);
          const [isLoading, setIsLoading] = useState(false);
          const [error, setError] = useState(null);

          const chatEndRef = useRef(null);

          useEffect(() => {
            if (chatEndRef.current) {
              chatEndRef.current.scrollIntoView({ behavior: 'smooth' });
            }
          }, [chatMessages]);

          const transformChatMessagesForApi = (messages) => {
            return messages
              .filter(msg => msg.sender === 'user' || msg.sender === 'gemini')
              .map(msg => ({
                role: msg.sender === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text }],
              }));
          };

          const callGeminiApi = async (userPrompt, currentChatHistory, currentFullCode, linesToEditInfo) => {
            setIsLoading(true);
            setError(null);
            // !!! IMPORTANT: REPLACE "" WITH YOUR ACTUAL GEMINI API KEY !!!
            const apiKey = typeof GEMINI_API_KEY !== 'undefined' ? GEMINI_API_KEY : "";

            if (!apiKey) {
                setError("Gemini APIキーが設定されていません。HTMLファイル内の`apiKey`変数を編集してください。");
                setIsLoading(false);
                return null;
            }

            const systemInstruction = `あなたは優秀なAIコーディングアシスタントです。ユーザーの指示に基づいてコードスニペットを生成または変更します。
指示された場合、特に既存のコードの特定行を編集するよう求められた場合は、自身の解説やマークダウンフォーマット（例: \`\`\`）を含めず、要求されたコードブロックの完全な新しいバージョンのみを提供してください。
生成するコードは、簡潔で、ユーザーの要求に直接応えるものにしてください。`;

            let constructedPrompt = userPrompt;
            if (linesToEditInfo && linesToEditInfo.lines.length > 0) {
              const originalCodeLines = currentFullCode.split('\n');
              const selectedCodeSnippets = linesToEditInfo.lines
                .map(ln => originalCodeLines[ln - 1])
                .filter(line => typeof line === 'string')
                .join('\n');
              
              constructedPrompt = `ユーザーは現在以下のコードの特定行（${linesToEditInfo.lines.join(', ')}行目）の編集を希望しています:\n\`\`\`\n${selectedCodeSnippets}\n\`\`\`\n\n編集指示は次の通りです: "${userPrompt}"\n\n上記の指示に基づき、これらの行を修正した新しいコードブロックのみを提供してください。あなたの解説や追加のテキストは不要です。`;
            }

            const apiChatHistory = transformChatMessagesForApi(currentChatHistory);

            const payload = {
              contents: [
                { role: "user", parts: [{ text: `System Instruction: ${systemInstruction}` }] },
                { role: "model", parts: [{ text: "はい、承知いたしました。コーディングのお手伝いをします。" }] },
                ...apiChatHistory,
                { role: "user", parts: [{ text: constructedPrompt }] }
              ],
            };

            try {
              const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
              });

              if (!response.ok) {
                const errorData = await response.json();
                console.error('Gemini API Error:', errorData);
                throw new Error(`APIエラー: ${errorData.error?.message || response.statusText} (ステータス: ${response.status})`);
              }

              const result = await response.json();

              if (result.candidates && result.candidates.length > 0 &&
                  result.candidates[0].content && result.candidates[0].content.parts &&
                  result.candidates[0].content.parts.length > 0) {
                let generatedText = result.candidates[0].content.parts[0].text;
                generatedText = generatedText.replace(/^```[\w]*\n?/gm, '').replace(/```$/gm, '').trim();
                return generatedText;
              } else {
                console.error('Gemini API Response format unexpected:', result);
                throw new Error('Geminiからの応答が予期した形式ではありません。');
              }
            } catch (e) {
              console.error('Gemini API Call failed:', e);
              setError(e.message || 'Gemini APIの呼び出し中に不明なエラーが発生しました。');
              return null;
            } finally {
              setIsLoading(false);
            }
          };

          const handleSendMessage = async () => {
            if (!userInput.trim()) return;

            const newUserMessage = { sender: 'user', text: userInput };
            const updatedChatMessages = [...chatMessages, newUserMessage];
            setChatMessages(updatedChatMessages);

            const currentEditingContext = editingContext;
            setUserInput('');

            const geminiResponseText = await callGeminiApi(newUserMessage.text, updatedChatMessages, code, currentEditingContext);

            if (geminiResponseText !== null) {
              const newGeminiMessage = {
                sender: 'gemini',
                text: geminiResponseText,
                isCodeSuggestion: true,
                editingContextSnapshot: currentEditingContext ? { ...currentEditingContext } : null,
              };
              setChatMessages(prev => [...prev, newGeminiMessage]);
            }
          };

          const handleApplyCode = (rawGeminiResponse, messageEditingContextSnapshot) => {
            setError(null);
            let codeToApply = rawGeminiResponse;

            if (messageEditingContextSnapshot && messageEditingContextSnapshot.lines.length > 0) {
                const currentCodeLines = code.split('\n');
                const linesToEditNumbers = messageEditingContextSnapshot.lines.sort((a, b) => a - b);
                
                const firstLineIndex = linesToEditNumbers[0] - 1;
                const lastLineIndex = linesToEditNumbers[linesToEditNumbers.length - 1] - 1;
                const linesToRemove = (lastLineIndex - firstLineIndex + 1);

                const newCodeBlockLines = codeToApply.split('\n');
                
                if (firstLineIndex < 0 || firstLineIndex > currentCodeLines.length && !(firstLineIndex === 0 && currentCodeLines.length === 0 && currentCodeLines[0] === '')) { // Allow insertion into empty editor
                    setError(`エラー: 編集開始行(${firstLineIndex + 1})が無効です。 (コード行数: ${currentCodeLines.length})`);
                    return;
                }
                
                currentCodeLines.splice(firstLineIndex, linesToRemove, ...newCodeBlockLines);
                setCode(currentCodeLines.join('\n'));

                setChatMessages(prev => [...prev, {sender: 'system', text: `${messageEditingContextSnapshot.lines.join(', ')}行目の編集が適用されました。`}]);
            } else {
                setCode(codeToApply);
                setChatMessages(prev => [...prev, {sender: 'system', text: 'コードがエディタに反映されました。'}]);
            }
            
            setEditingContext(null);
            setCurrentScreen('editor');
            setSelectedLines([]);
          };

          const handleEditSelectedLines = () => {
            if (selectedLines.length === 0) {
              setChatMessages(prev => [...prev, {sender: 'system', text: '編集する行を選択してください。'}]);
              return;
            }
            const sortedSelectedLines = [...selectedLines].sort((a, b) => a - b);
            setEditingContext({ lines: sortedSelectedLines });
            setCurrentScreen('chat');
            setUserInput(''); 
            setChatMessages(prev => [
                ...prev,
                {sender: 'system', text: `${sortedSelectedLines.join(', ')}行目を編集します。編集内容を指示してください。`}
            ]);
            setError(null);
          };

          const toggleLineSelection = (lineNumber) => {
            setSelectedLines(prev =>
              prev.includes(lineNumber)
                ? prev.filter(ln => ln !== lineNumber)
                : [...prev, lineNumber]
            );
          };

          const renderChatScreen = () => (
            <div className="flex flex-col h-full bg-gray-800 text-white">
              <header className="p-4 bg-gray-900 shadow-md flex items-center justify-between">
                <div className="flex items-center">
                  <Bot size={28} className="mr-2 text-blue-400" />
                  <h1 className="text-xl font-semibold">Geminiチャット</h1>
                </div>
                <button
                  onClick={() => { setCurrentScreen('editor'); }}
                  className="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out flex items-center"
                  disabled={!code && currentScreen === 'chat'}
                  title={!code && currentScreen === 'chat' ? "反映するコードがありません" : "エディタ画面へ"}
                >
                  エディタ <ChevronRight size={20} className="ml-1" />
                </button>
              </header>
              <div className="flex-grow p-4 overflow-y-auto space-y-4 bg-gray-700/50">
                {error && (
                    <div className="my-2 p-3 bg-red-800/80 text-white rounded-lg shadow flex items-center">
                        <AlertTriangle size={20} className="mr-2 text-red-300" />
                        <div>
                            <p className="font-semibold">エラーが発生しました:</p>
                            <p className="text-sm">{error}</p>
                        </div>
                    </div>
                )}
                {chatMessages.map((msg, index) => (
                  <div key={index} className={`flex ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
                    <div className={`max-w-2xl p-3 rounded-xl shadow-lg ${
                      msg.sender === 'user' ? 'bg-blue-600 text-white rounded-br-none' :
                      msg.sender === 'gemini' ? 'bg-gray-600 text-gray-100 rounded-bl-none' :
                      'bg-yellow-600/30 text-yellow-100 text-sm italic text-center w-full py-2 rounded-md'
                    }`}>
                      {msg.sender === 'gemini' && <Bot size={18} className="inline mr-2 mb-1 text-blue-300" />}
                      {msg.sender === 'user' && <User size={18} className="inline mr-2 mb-1 text-blue-300" />}
                      {typeof msg.text === 'string' && msg.text.split('\n').map((line, i) => (
                        <span key={i} className="block whitespace-pre-wrap">{line}</span>
                      ))}
                      {msg.isCodeSuggestion && msg.sender === 'gemini' && msg.text && (
                        <button
                          onClick={() => handleApplyCode(msg.text, msg.editingContextSnapshot)}
                          className="mt-3 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-3 rounded-lg shadow-md transition duration-150 ease-in-out text-sm flex items-center"
                        >
                          <CheckSquare size={16} className="mr-1.5" /> コードを反映
                        </button>
                      )}
                    </div>
                  </div>
                ))}
                {isLoading && (
                    <div className="flex justify-center items-center p-4">
                        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-400"></div>
                        <p className="ml-3 text-gray-300">Geminiが考え中...</p>
                    </div>
                )}
                <div ref={chatEndRef} />
              </div>
              <div className="p-4 bg-gray-900 border-t border-gray-700">
                <div className="flex items-center space-x-2">
                  <input
                    type="text"
                    value={userInput}
                    onChange={(e) => setUserInput(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && !isLoading && handleSendMessage()}
                    placeholder={editingContext ? `${editingContext.lines.join(', ')}行目の編集内容を入力...` : "Geminiにメッセージを送信..."}
                    className="flex-grow p-3 bg-gray-700 text-white rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none shadow-inner"
                    disabled={isLoading}
                  />
                  <button
                    onClick={handleSendMessage}
                    className="bg-blue-500 hover:bg-blue-600 text-white font-semibold p-3 rounded-lg shadow transition duration-150 ease-in-out flex items-center justify-center"
                    disabled={isLoading || !userInput.trim()}
                  >
                    <Send size={20} />
                  </button>
                </div>
              </div>
            </div>
          );

          const renderEditorScreen = () => (
            <div className="flex flex-col h-full bg-gray-800 text-white">
              <header className="p-4 bg-gray-900 shadow-md flex items-center justify-between">
                <div className="flex items-center">
                  <Edit3 size={28} className="mr-2 text-green-400" />
                  <h1 className="text-xl font-semibold">コードエディタ</h1>
                </div>
                <div className="flex items-center space-x-3">
                   <button
                    onClick={() => {
                        setCurrentScreen('chat');
                        setChatMessages(prev => [...prev, {sender: 'system', text: 'チャット画面に戻りました。'}]);
                        setError(null);
                    }}
                    className="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out flex items-center"
                  >
                    <MessageSquare size={20} className="mr-1.5" /> チャットへ
                  </button>
                  <button
                    onClick={handleEditSelectedLines}
                    disabled={selectedLines.length === 0}
                    className={`font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out flex items-center ${
                      selectedLines.length > 0 ? 'bg-yellow-500 hover:bg-yellow-600 text-black' : 'bg-gray-600 text-gray-400 cursor-not-allowed'
                    }`}
                    title={selectedLines.length === 0 ? "編集する行を選択してください" : "選択行を編集"}
                  >
                    <Edit3 size={20} className="mr-1.5" /> 選択行を編集
                  </button>
                </div>
              </header>
              <div className="flex-grow p-4 overflow-auto bg-gray-700/50">
                {error && (
                     <div className="mb-4 p-3 bg-red-800/80 text-white rounded-lg shadow flex items-center">
                        <AlertTriangle size={20} className="mr-2 text-red-300" />
                        <div>
                            <p className="font-semibold">エラー:</p>
                            <p className="text-sm">{error}</p>
                        </div>
                    </div>
                )}
                {code.split('\n').map((line, index) => {
                  const lineNumber = index + 1;
                  const isSelected = selectedLines.includes(lineNumber);
                  return (
                    <div key={lineNumber} className={`flex items-center p-1.5 rounded hover:bg-gray-600/70 ${isSelected ? 'bg-blue-900/60' : ''} transition-colors duration-100`}>
                      <div className="mr-3 select-none cursor-pointer" onClick={() => toggleLineSelection(lineNumber)}>
                        {isSelected ? <CheckSquare size={20} className="text-blue-400" /> : <Square size={20} className="text-gray-500 hover:text-gray-400" />}
                      </div>
                      <span className="text-gray-400 mr-3 w-8 text-right select-none">{lineNumber}.</span>
                      <pre className="whitespace-pre-wrap flex-grow text-gray-100 font-mono text-sm">{line || ' '}</pre>
                    </div>
                  );
                })}
                {code.length === 0 && !error && (
                    <div className="text-center text-gray-400 mt-10">
                        <p className="text-lg">エディタは空です。</p>
                        <p>チャット画面でコードを生成し、「コードを反映」ボタンを押してください。</p>
                    </div>
                )}
              </div>
              <footer className="p-3 bg-gray-900 border-t border-gray-700 flex justify-end">
                <button
                    onClick={() => {
                        if (typeof navigator.clipboard?.writeText === 'function') {
                            navigator.clipboard.writeText(code)
                                .then(() => setChatMessages(prev => [...prev, {sender: 'system', text: 'コードがクリップボードにコピーされました。'}]))
                                .catch(err => {
                                    console.error('クリップボードへのコピーに失敗:', err);
                                    setChatMessages(prev => [...prev, {sender: 'system', text: 'クリップボードへのコピーに失敗しました。'}]);
                                });
                        } else {
                            const textArea = document.createElement("textarea");
                            textArea.value = code;
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            try {
                                document.execCommand('copy');
                                setChatMessages(prev => [...prev, {sender: 'system', text: 'コードがクリップボードにコピーされました。(フォールバック)'}]);
                            } catch (err) {
                                console.error('クリップボードへのコピーに失敗 (フォールバック):', err);
                                setChatMessages(prev => [...prev, {sender: 'system', text: 'クリップボードへのコピーに失敗しました。(フォールバック)'}]);
                            }
                            document.body.removeChild(textArea);
                        }
                        setCurrentScreen('chat');
                    }}
                    className="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out flex items-center"
                    disabled={!code}
                >
                    <Save size={18} className="mr-1.5" /> クリップボードにコピー
                </button>
              </footer>
            </div>
          );

          return (
            <div className="h-screen w-screen font-sans overflow-hidden">
              {currentScreen === 'chat' ? renderChatScreen() : renderEditorScreen()}
            </div>
          );
        };

        // Render the App component to the #root div
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>