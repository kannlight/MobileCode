<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ä¸è¦ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿ (ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* åŸºæœ¬çš„ãªãƒ•ã‚©ãƒ³ãƒˆè¨­å®šãªã© */
        body {
            font-family: sans-serif; /* TailwindãŒè¨­å®šã—ã¾ã™ãŒå¿µã®ãŸã‚ */
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* Appã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ«ã«åˆã‚ã›ã‚‹ */
        }
        #root {
            height: 100%;
            width: 100%;
        }
        /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰*/
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Simple replacements for Lucide icons (using emojis or text)
        const ChevronRight = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>&gt;</span>;
        const MessageSquare = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>ğŸ’¬</span>;
        const Edit3 = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>âœï¸</span>;
        const CheckSquare = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>â˜‘ï¸</span>;
        const Square = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>â¬œ</span>;
        const Save = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>ğŸ’¾</span>;
        const Send = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>â¢</span>;
        const Bot = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>ğŸ¤–</span>;
        const User = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>ğŸ‘¤</span>;
        const AlertTriangle = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>âš ï¸</span>;
        // PlusCircle, Trash2, Settings are not directly used in the final UI logic based on your provided React code.

        // --- React Component Code (from your provided script) ---
        // Renamed React imports to avoid conflict with global React from CDN
        const { useState, useEffect, useRef } = React;

        // Firebase imports are commented out as they are not used in local setup without config
        // import { initializeApp } from 'firebase/app';
        // import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
        // import { getFirestore, doc, setDoc, getDoc, collection, addDoc, onSnapshot, query, where, updateDoc, deleteDoc } from 'firebase/firestore';

        // const firebaseConfig = {};
        // const appId = 'default-app-id';
        // const initialAuthToken = null;

        const App = () => {
          const [currentScreen, setCurrentScreen] = useState('chat'); // 'chat' or 'editor'
          const [chatMessages, setChatMessages] = useState([
            { sender: 'gemini', text: 'ã“ã‚“ã«ã¡ã¯ï¼ã©ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¾ã™ã‹ï¼Ÿã¾ãŸã¯ã€æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã‚’ç·¨é›†ã—ã¾ã™ã‹ï¼Ÿ', isCodeSuggestion: false }
          ]);
          const [code, setCode] = useState('');
          const [selectedLines, setSelectedLines] = useState([]);
          const [userInput, setUserInput] = useState('');
          const [editingContext, setEditingContext] = useState(null);
          const [isLoading, setIsLoading] = useState(false);
          const [error, setError] = useState(null);

          const chatEndRef = useRef(null);

          useEffect(() => {
            if (chatEndRef.current) {
              chatEndRef.current.scrollIntoView({ behavior: 'smooth' });
            }
          }, [chatMessages]);

          const transformChatMessagesForApi = (messages) => {
            return messages
              .filter(msg => msg.sender === 'user' || msg.sender === 'gemini')
              .map(msg => ({
                role: msg.sender === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text }],
              }));
          };

          const callGeminiApi = async (userPrompt, currentChatHistory, currentFullCode, linesToEditInfo) => {
            setIsLoading(true);
            setError(null);
            // !!! IMPORTANT: REPLACE "" WITH YOUR ACTUAL GEMINI API KEY !!!
            const apiKey = typeof GEMINI_API_KEY !== 'undefined' ? GEMINI_API_KEY : "";

            if (!apiKey) {
                setError("Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚HTMLãƒ•ã‚¡ã‚¤ãƒ«å†…ã®`apiKey`å¤‰æ•°ã‚’ç·¨é›†ã—ã¦ãã ã•ã„ã€‚");
                setIsLoading(false);
                return null;
            }

            const systemInstruction = `ã‚ãªãŸã¯å„ªç§€ãªAIã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æŒ‡ç¤ºã«åŸºã¥ã„ã¦ã‚³ãƒ¼ãƒ‰ã‚¹ãƒ‹ãƒšãƒƒãƒˆã‚’ç”Ÿæˆã¾ãŸã¯å¤‰æ›´ã—ã¾ã™ã€‚
æŒ‡ç¤ºã•ã‚ŒãŸå ´åˆã€ç‰¹ã«æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã®ç‰¹å®šè¡Œã‚’ç·¨é›†ã™ã‚‹ã‚ˆã†æ±‚ã‚ã‚‰ã‚ŒãŸå ´åˆã¯ã€è‡ªèº«ã®è§£èª¬ã‚„ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆä¾‹: \`\`\`ï¼‰ã‚’å«ã‚ãšã€è¦æ±‚ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®å®Œå…¨ãªæ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã¿ã‚’æä¾›ã—ã¦ãã ã•ã„ã€‚
ç”Ÿæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã€ç°¡æ½”ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¦æ±‚ã«ç›´æ¥å¿œãˆã‚‹ã‚‚ã®ã«ã—ã¦ãã ã•ã„ã€‚`;

            let constructedPrompt = userPrompt;
            if (linesToEditInfo && linesToEditInfo.lines.length > 0) {
              const originalCodeLines = currentFullCode.split('\n');
              const selectedCodeSnippets = linesToEditInfo.lines
                .map(ln => originalCodeLines[ln - 1])
                .filter(line => typeof line === 'string')
                .join('\n');
              
              constructedPrompt = `ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ç¾åœ¨ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã®ç‰¹å®šè¡Œï¼ˆ${linesToEditInfo.lines.join(', ')}è¡Œç›®ï¼‰ã®ç·¨é›†ã‚’å¸Œæœ›ã—ã¦ã„ã¾ã™:\n\`\`\`\n${selectedCodeSnippets}\n\`\`\`\n\nç·¨é›†æŒ‡ç¤ºã¯æ¬¡ã®é€šã‚Šã§ã™: "${userPrompt}"\n\nä¸Šè¨˜ã®æŒ‡ç¤ºã«åŸºã¥ãã€ã“ã‚Œã‚‰ã®è¡Œã‚’ä¿®æ­£ã—ãŸæ–°ã—ã„ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®ã¿ã‚’æä¾›ã—ã¦ãã ã•ã„ã€‚ã‚ãªãŸã®è§£èª¬ã‚„è¿½åŠ ã®ãƒ†ã‚­ã‚¹ãƒˆã¯ä¸è¦ã§ã™ã€‚`;
            }

            const apiChatHistory = transformChatMessagesForApi(currentChatHistory);

            const payload = {
              contents: [
                { role: "user", parts: [{ text: `System Instruction: ${systemInstruction}` }] },
                { role: "model", parts: [{ text: "ã¯ã„ã€æ‰¿çŸ¥ã„ãŸã—ã¾ã—ãŸã€‚ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ãŠæ‰‹ä¼ã„ã‚’ã—ã¾ã™ã€‚" }] },
                ...apiChatHistory,
                { role: "user", parts: [{ text: constructedPrompt }] }
              ],
            };

            try {
              const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
              });

              if (!response.ok) {
                const errorData = await response.json();
                console.error('Gemini API Error:', errorData);
                throw new Error(`APIã‚¨ãƒ©ãƒ¼: ${errorData.error?.message || response.statusText} (ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status})`);
              }

              const result = await response.json();

              if (result.candidates && result.candidates.length > 0 &&
                  result.candidates[0].content && result.candidates[0].content.parts &&
                  result.candidates[0].content.parts.length > 0) {
                let generatedText = result.candidates[0].content.parts[0].text;
                generatedText = generatedText.replace(/^```[\w]*\n?/gm, '').replace(/```$/gm, '').trim();
                return generatedText;
              } else {
                console.error('Gemini API Response format unexpected:', result);
                throw new Error('Geminiã‹ã‚‰ã®å¿œç­”ãŒäºˆæœŸã—ãŸå½¢å¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚');
              }
            } catch (e) {
              console.error('Gemini API Call failed:', e);
              setError(e.message || 'Gemini APIã®å‘¼ã³å‡ºã—ä¸­ã«ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
              return null;
            } finally {
              setIsLoading(false);
            }
          };

          const handleSendMessage = async () => {
            if (!userInput.trim()) return;

            const newUserMessage = { sender: 'user', text: userInput };
            const updatedChatMessages = [...chatMessages, newUserMessage];
            setChatMessages(updatedChatMessages);

            const currentEditingContext = editingContext;
            setUserInput('');

            const geminiResponseText = await callGeminiApi(newUserMessage.text, updatedChatMessages, code, currentEditingContext);

            if (geminiResponseText !== null) {
              const newGeminiMessage = {
                sender: 'gemini',
                text: geminiResponseText,
                isCodeSuggestion: true,
                editingContextSnapshot: currentEditingContext ? { ...currentEditingContext } : null,
              };
              setChatMessages(prev => [...prev, newGeminiMessage]);
            }
          };

          const handleApplyCode = (rawGeminiResponse, messageEditingContextSnapshot) => {
            setError(null);
            let codeToApply = rawGeminiResponse;

            if (messageEditingContextSnapshot && messageEditingContextSnapshot.lines.length > 0) {
                const currentCodeLines = code.split('\n');
                const linesToEditNumbers = messageEditingContextSnapshot.lines.sort((a, b) => a - b);
                
                const firstLineIndex = linesToEditNumbers[0] - 1;
                const lastLineIndex = linesToEditNumbers[linesToEditNumbers.length - 1] - 1;
                const linesToRemove = (lastLineIndex - firstLineIndex + 1);

                const newCodeBlockLines = codeToApply.split('\n');
                
                if (firstLineIndex < 0 || firstLineIndex > currentCodeLines.length && !(firstLineIndex === 0 && currentCodeLines.length === 0 && currentCodeLines[0] === '')) { // Allow insertion into empty editor
                    setError(`ã‚¨ãƒ©ãƒ¼: ç·¨é›†é–‹å§‹è¡Œ(${firstLineIndex + 1})ãŒç„¡åŠ¹ã§ã™ã€‚ (ã‚³ãƒ¼ãƒ‰è¡Œæ•°: ${currentCodeLines.length})`);
                    return;
                }
                
                currentCodeLines.splice(firstLineIndex, linesToRemove, ...newCodeBlockLines);
                setCode(currentCodeLines.join('\n'));

                setChatMessages(prev => [...prev, {sender: 'system', text: `${messageEditingContextSnapshot.lines.join(', ')}è¡Œç›®ã®ç·¨é›†ãŒé©ç”¨ã•ã‚Œã¾ã—ãŸã€‚`}]);
            } else {
                setCode(codeToApply);
                setChatMessages(prev => [...prev, {sender: 'system', text: 'ã‚³ãƒ¼ãƒ‰ãŒã‚¨ãƒ‡ã‚£ã‚¿ã«åæ˜ ã•ã‚Œã¾ã—ãŸã€‚'}]);
            }
            
            setEditingContext(null);
            setCurrentScreen('editor');
            setSelectedLines([]);
          };

          const handleEditSelectedLines = () => {
            if (selectedLines.length === 0) {
              setChatMessages(prev => [...prev, {sender: 'system', text: 'ç·¨é›†ã™ã‚‹è¡Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'}]);
              return;
            }
            const sortedSelectedLines = [...selectedLines].sort((a, b) => a - b);
            setEditingContext({ lines: sortedSelectedLines });
            setCurrentScreen('chat');
            setUserInput(''); 
            setChatMessages(prev => [
                ...prev,
                {sender: 'system', text: `${sortedSelectedLines.join(', ')}è¡Œç›®ã‚’ç·¨é›†ã—ã¾ã™ã€‚ç·¨é›†å†…å®¹ã‚’æŒ‡ç¤ºã—ã¦ãã ã•ã„ã€‚`}
            ]);
            setError(null);
          };

          const toggleLineSelection = (lineNumber) => {
            setSelectedLines(prev =>
              prev.includes(lineNumber)
                ? prev.filter(ln => ln !== lineNumber)
                : [...prev, lineNumber]
            );
          };

          const renderChatScreen = () => (
            <div className="flex flex-col h-full bg-gray-800 text-white">
              <header className="p-4 bg-gray-900 shadow-md flex items-center justify-between">
                <div className="flex items-center">
                  <Bot size={28} className="mr-2 text-blue-400" />
                  <h1 className="text-xl font-semibold">Geminiãƒãƒ£ãƒƒãƒˆ</h1>
                </div>
                <button
                  onClick={() => { setCurrentScreen('editor'); }}
                  className="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out flex items-center"
                  disabled={!code && currentScreen === 'chat'}
                  title={!code && currentScreen === 'chat' ? "åæ˜ ã™ã‚‹ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“" : "ã‚¨ãƒ‡ã‚£ã‚¿ç”»é¢ã¸"}
                >
                  ã‚¨ãƒ‡ã‚£ã‚¿ <ChevronRight size={20} className="ml-1" />
                </button>
              </header>
              <div className="flex-grow p-4 overflow-y-auto space-y-4 bg-gray-700/50">
                {error && (
                    <div className="my-2 p-3 bg-red-800/80 text-white rounded-lg shadow flex items-center">
                        <AlertTriangle size={20} className="mr-2 text-red-300" />
                        <div>
                            <p className="font-semibold">ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:</p>
                            <p className="text-sm">{error}</p>
                        </div>
                    </div>
                )}
                {chatMessages.map((msg, index) => (
                  <div key={index} className={`flex ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
                    <div className={`max-w-2xl p-3 rounded-xl shadow-lg ${
                      msg.sender === 'user' ? 'bg-blue-600 text-white rounded-br-none' :
                      msg.sender === 'gemini' ? 'bg-gray-600 text-gray-100 rounded-bl-none' :
                      'bg-yellow-600/30 text-yellow-100 text-sm italic text-center w-full py-2 rounded-md'
                    }`}>
                      {msg.sender === 'gemini' && <Bot size={18} className="inline mr-2 mb-1 text-blue-300" />}
                      {msg.sender === 'user' && <User size={18} className="inline mr-2 mb-1 text-blue-300" />}
                      {typeof msg.text === 'string' && msg.text.split('\n').map((line, i) => (
                        <span key={i} className="block whitespace-pre-wrap">{line}</span>
                      ))}
                      {msg.isCodeSuggestion && msg.sender === 'gemini' && msg.text && (
                        <button
                          onClick={() => handleApplyCode(msg.text, msg.editingContextSnapshot)}
                          className="mt-3 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-3 rounded-lg shadow-md transition duration-150 ease-in-out text-sm flex items-center"
                        >
                          <CheckSquare size={16} className="mr-1.5" /> ã‚³ãƒ¼ãƒ‰ã‚’åæ˜ 
                        </button>
                      )}
                    </div>
                  </div>
                ))}
                {isLoading && (
                    <div className="flex justify-center items-center p-4">
                        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-400"></div>
                        <p className="ml-3 text-gray-300">GeminiãŒè€ƒãˆä¸­...</p>
                    </div>
                )}
                <div ref={chatEndRef} />
              </div>
              <div className="p-4 bg-gray-900 border-t border-gray-700">
                <div className="flex items-center space-x-2">
                  <input
                    type="text"
                    value={userInput}
                    onChange={(e) => setUserInput(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && !isLoading && handleSendMessage()}
                    placeholder={editingContext ? `${editingContext.lines.join(', ')}è¡Œç›®ã®ç·¨é›†å†…å®¹ã‚’å…¥åŠ›...` : "Geminiã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡..."}
                    className="flex-grow p-3 bg-gray-700 text-white rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none shadow-inner"
                    disabled={isLoading}
                  />
                  <button
                    onClick={handleSendMessage}
                    className="bg-blue-500 hover:bg-blue-600 text-white font-semibold p-3 rounded-lg shadow transition duration-150 ease-in-out flex items-center justify-center"
                    disabled={isLoading || !userInput.trim()}
                  >
                    <Send size={20} />
                  </button>
                </div>
              </div>
            </div>
          );

          const renderEditorScreen = () => (
            <div className="flex flex-col h-full bg-gray-800 text-white">
              <header className="p-4 bg-gray-900 shadow-md flex items-center justify-between">
                <div className="flex items-center">
                  <Edit3 size={28} className="mr-2 text-green-400" />
                  <h1 className="text-xl font-semibold">ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿</h1>
                </div>
                <div className="flex items-center space-x-3">
                   <button
                    onClick={() => {
                        setCurrentScreen('chat');
                        setChatMessages(prev => [...prev, {sender: 'system', text: 'ãƒãƒ£ãƒƒãƒˆç”»é¢ã«æˆ»ã‚Šã¾ã—ãŸã€‚'}]);
                        setError(null);
                    }}
                    className="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out flex items-center"
                  >
                    <MessageSquare size={20} className="mr-1.5" /> ãƒãƒ£ãƒƒãƒˆã¸
                  </button>
                  <button
                    onClick={handleEditSelectedLines}
                    disabled={selectedLines.length === 0}
                    className={`font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out flex items-center ${
                      selectedLines.length > 0 ? 'bg-yellow-500 hover:bg-yellow-600 text-black' : 'bg-gray-600 text-gray-400 cursor-not-allowed'
                    }`}
                    title={selectedLines.length === 0 ? "ç·¨é›†ã™ã‚‹è¡Œã‚’é¸æŠã—ã¦ãã ã•ã„" : "é¸æŠè¡Œã‚’ç·¨é›†"}
                  >
                    <Edit3 size={20} className="mr-1.5" /> é¸æŠè¡Œã‚’ç·¨é›†
                  </button>
                </div>
              </header>
              <div className="flex-grow p-4 overflow-auto bg-gray-700/50">
                {error && (
                     <div className="mb-4 p-3 bg-red-800/80 text-white rounded-lg shadow flex items-center">
                        <AlertTriangle size={20} className="mr-2 text-red-300" />
                        <div>
                            <p className="font-semibold">ã‚¨ãƒ©ãƒ¼:</p>
                            <p className="text-sm">{error}</p>
                        </div>
                    </div>
                )}
                {code.split('\n').map((line, index) => {
                  const lineNumber = index + 1;
                  const isSelected = selectedLines.includes(lineNumber);
                  return (
                    <div key={lineNumber} className={`flex items-center p-1.5 rounded hover:bg-gray-600/70 ${isSelected ? 'bg-blue-900/60' : ''} transition-colors duration-100`}>
                      <div className="mr-3 select-none cursor-pointer" onClick={() => toggleLineSelection(lineNumber)}>
                        {isSelected ? <CheckSquare size={20} className="text-blue-400" /> : <Square size={20} className="text-gray-500 hover:text-gray-400" />}
                      </div>
                      <span className="text-gray-400 mr-3 w-8 text-right select-none">{lineNumber}.</span>
                      <pre className="whitespace-pre-wrap flex-grow text-gray-100 font-mono text-sm">{line || ' '}</pre>
                    </div>
                  );
                })}
                {code.length === 0 && !error && (
                    <div className="text-center text-gray-400 mt-10">
                        <p className="text-lg">ã‚¨ãƒ‡ã‚£ã‚¿ã¯ç©ºã§ã™ã€‚</p>
                        <p>ãƒãƒ£ãƒƒãƒˆç”»é¢ã§ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã€ã€Œã‚³ãƒ¼ãƒ‰ã‚’åæ˜ ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>
                    </div>
                )}
              </div>
              <footer className="p-3 bg-gray-900 border-t border-gray-700 flex justify-end">
                <button
                    onClick={() => {
                        if (typeof navigator.clipboard?.writeText === 'function') {
                            navigator.clipboard.writeText(code)
                                .then(() => setChatMessages(prev => [...prev, {sender: 'system', text: 'ã‚³ãƒ¼ãƒ‰ãŒã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸã€‚'}]))
                                .catch(err => {
                                    console.error('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—:', err);
                                    setChatMessages(prev => [...prev, {sender: 'system', text: 'ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'}]);
                                });
                        } else {
                            const textArea = document.createElement("textarea");
                            textArea.value = code;
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            try {
                                document.execCommand('copy');
                                setChatMessages(prev => [...prev, {sender: 'system', text: 'ã‚³ãƒ¼ãƒ‰ãŒã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸã€‚(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)'}]);
                            } catch (err) {
                                console.error('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•— (ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯):', err);
                                setChatMessages(prev => [...prev, {sender: 'system', text: 'ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)'}]);
                            }
                            document.body.removeChild(textArea);
                        }
                        setCurrentScreen('chat');
                    }}
                    className="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out flex items-center"
                    disabled={!code}
                >
                    <Save size={18} className="mr-1.5" /> ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
                </button>
              </footer>
            </div>
          );

          return (
            <div className="h-screen w-screen font-sans overflow-hidden">
              {currentScreen === 'chat' ? renderChatScreen() : renderEditorScreen()}
            </div>
          );
        };

        // Render the App component to the #root div
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>