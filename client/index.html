<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>統合アプリ (コードエディタ & SSHファイルマネージャー)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            background-color: #1a202c; /* bg-gray-900 */
        }
        #root {
            height: 100%;
            width: 100%;
        }
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Lucideアイコンの簡易的な代替
        const ChevronRight = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>&gt;</span>;
        const MessageSquare = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>💬</span>;
        const Edit3 = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>✏️</span>;
        const CheckSquare = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>☑️</span>;
        const Square = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>⬜</span>;
        const Save = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>💾</span>;
        const Send = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>➢</span>;
        const Bot = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>🤖</span>;
        const User = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>👤</span>;
        const AlertTriangle = ({ size, className }) => <span className={className} style={{ fontSize: size ? `${size}px` : 'inherit' }}>⚠️</span>;
        const BACKENDURL  = "https://mobilecode-127885133532.asia-northeast1.run.app";

        // アイコン
        const Server = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect>
            <rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect>
            <path d="M7 6h.01"></path>
            <path d="M7 18h.01"></path>
          </svg>
        );
        const Folder = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
          </svg>
        );
        const FileText = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
            <line x1="16" y1="13" x2="8" y2="13"></line>
            <line x1="16" y1="17" x2="8" y2="17"></line>
            <line x1="10" y1="9" x2="8" y2="9"></line>
          </svg>
        );
        const EditFileIcon = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <path d="M12 20h9"></path>
            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
          </svg>
        );
        const Upload = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
        );
        const ArrowLeft = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <line x1="19" y1="12" x2="5" y2="12"></line>
            <polyline points="12 19 5 12 12 5"></polyline>
          </svg>
        );
        const Home = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
            <polyline points="9 22 9 12 15 12 15 22"></polyline>
          </svg>
        );
        const RefreshCw = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <path d="M21.5 2v6h-6"></path>
            <path d="M2.5 22v-6h6"></path>
            <path d="M2.5 16a9 9 0 0 1 18.5-4 9 9 0 0 1-2.3 8.3L21.5 22"></path>
            <path d="M21.5 8a9 9 0 0 0-18.5 4 9 9 0 0 0 2.3-8.3L2.5 2"></path>
          </svg>
        );
        const HardDrive = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <line x1="22" y1="12" x2="2" y2="12"></line>
            <path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>
            <line x1="6" y1="16" x2="6.01" y2="16"></line>
            <line x1="10" y1="16" x2="10.01" y2="16"></line>
          </svg>
        );
        const Terminal = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <polyline points="4 17 10 11 4 5"></polyline>
            <line x1="12" y1="19" x2="20" y2="19"></line>
          </svg>
        );
        const Command = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3z"></path>
            <path d="M6 3a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3 3 3 0 0 1-3-3V6a3 3 0 0 1 3-3z"></path>
            <path d="M12 2v20"></path>
          </svg>
        );
        const Plus = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
          </svg>
        );
        const Trash2 = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            <line x1="10" y1="11" x2="10" y2="17"></line>
            <line x1="14" y1="11" x2="14" y2="17"></line>
          </svg>
        );

        const { useState, useEffect, useRef } = React;

        // メインアプリケーションコンポーネント
        const App = () => {
            const [isRemote, setIsRemote] = useState(false);
            const [showConnectionModal, setShowConnectionModal] = useState(false);
            const [activeTab, setActiveTab] = useState('chat'); // 初期タブをチャットに
            const [showEditorTab, setShowEditorTab] = useState(false); // エディタタブの表示状態

            const [chatMessages, setChatMessages] = useState([
                { sender: 'gemini', text: 'こんにちは！どのようなコードを作成しますか？', isCodeSuggestion: false }
            ]);
            const [code, setCode] = useState('');
            const [originalCode, setOriginalCode] = useState('');
            const [editingFilePath, setEditingFilePath] = useState(null);
            const [selectedLines, setSelectedLines] = useState([]);
            const [allLinesSelected, setAllLinesSelected] = useState(false); // ★追加★
            const [userInput, setUserInput] = useState('');
            const [editingContext, setEditingContext] = useState(null);
            const [isGeminiLoading, setIsGeminiLoading] = useState(false);
            const [isBackendLoading, setIsBackendLoading] = useState(false);
            const [error, setError] = useState(null);
            const [notification, setNotification] = useState(null);
            const chatEndRef = useRef(null);

            const [connectionInfo, setConnectionInfo] = useState({
                ip: '', port: '22', username: '', password: '',
            });

            const [remoteFiles, setRemoteFiles] = useState([]);
            const [currentRemotePath, setCurrentRemotePath] = useState('/');

            const [commandInput, setCommandInput] = useState('');
            const [commandOutput, setCommandOutput] = useState('');
            const [isCommandExecuting, setIsCommandExecuting] = useState(false);
            const [customCommands, setCustomCommands] = useState([]);
            const [newCustomCommandName, setNewCustomCommandName] = useState('');
            const [newCustomCommandValue, setNewCustomCommandValue] = useState('');
            const commandOutputRef = useRef(null);

            const showNotification = (message, isError = false) => {
                setNotification({ message, isError });
                setTimeout(() => {
                    setNotification(null);
                }, 3000); // 3秒後に通知を消す
            };

            useEffect(() => {
                if (chatEndRef.current) {
                    chatEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [chatMessages]);

            useEffect(() => {
                try {
                    const storedCommands = localStorage.getItem('customSshCommands');
                    if (storedCommands) {
                        setCustomCommands(JSON.parse(storedCommands));
                    }
                } catch (e) {
                    console.error("カスタムコマンドのロードに失敗しました:", e);
                }
            }, []);

            useEffect(() => {
                if (commandOutputRef.current) {
                    commandOutputRef.current.scrollTop = commandOutputRef.current.scrollHeight;
                }
            }, [commandOutput]);

            useEffect(() => {
                if (code.split('\n').length > 0 && selectedLines.length === code.split('\n').length) {
                    setAllLinesSelected(true);
                } else {
                    setAllLinesSelected(false);
                }
            }, [selectedLines, code]);

            const callBackendApi = async (endpoint, data) => {
                setIsBackendLoading(true);
                setError(null);
                try {
                    const backendUrl = BACKENDURL;
                    const response = await fetch(`${backendUrl}${endpoint}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ...connectionInfo, ...data }),
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || `APIリクエスト失敗: ${response.status}`);
                    }
                    const result = await response.json();
                    if (result && result.success === false) {
                        throw new Error(result.message || result.error || 'APIからエラーが返されました。');
                    }
                    return result;
                } catch (e) {
                    console.error('バックエンドAPI呼び出し失敗:', e);
                    setError(e.message || 'バックエンドサービスへの接続に失敗しました。');
                    return null;
                } finally {
                    setIsBackendLoading(false);
                }
            };
            
            const handleConnect = async () => {
                if (!connectionInfo.ip || !connectionInfo.username || !connectionInfo.password) {
                    setError('すべての接続情報を入力してください。');
                    return;
                }
                const result = await callBackendApi('/connect', connectionInfo);
                if (result && result.success) {
                    setIsRemote(true);
                    setShowConnectionModal(false);
                    setActiveTab('files');
                    fetchRemoteFiles('/');
                }
            };

            const handleDisconnect = () => {
                setIsRemote(false);
                setShowEditorTab(false);
                setConnectionInfo({ ip: '', port: '22', username: '', password: '' });
                setRemoteFiles([]);
                setCurrentRemotePath('/');
                setCode('');
                setOriginalCode('');
                setEditingFilePath(null);
                setActiveTab('chat');
                setError(null);
            };

            const fetchRemoteFiles = async (path) => {
                const result = await callBackendApi('/list', { path });
                if (result && result.success) {
                    setRemoteFiles(result.files);
                    setCurrentRemotePath(path);
                } else {
                    setRemoteFiles([]);
                }
            };

            const handleFileItemClick = (item) => {
                if (item.type === 'directory') {
                    const newPath = `${currentRemotePath === '/' ? '' : currentRemotePath}/${item.name}`;
                    fetchRemoteFiles(newPath);
                }
            };

            const handleEditFile = async (fileName) => {
                const filePath = `${currentRemotePath === '/' ? '' : currentRemotePath}/${fileName}`;
                const result = await callBackendApi('/download', { path: filePath });
                if (result && result.success && typeof result.fileContent === 'string') {
                    try {
                        const decodedContent = atob(result.fileContent);
                        setCode(decodedContent);
                        setOriginalCode(decodedContent);
                        setEditingFilePath(filePath);
                        setShowEditorTab(true);
                        setActiveTab('editor');
                        setError(null);
                    } catch (e) {
                        console.error("Base64デコード失敗:", e);
                        setError("ファイルのデコードに失敗しました。");
                    }
                }
            };
            
            const handleSaveAndUpdate = async () => {
                if (!editingFilePath || code === originalCode) {
                    return;
                }
                const contentToUpload = btoa(unescape(encodeURIComponent(code)));
                
                const result = await callBackendApi('/upload', { 
                    path: editingFilePath,
                    content: contentToUpload
                });

                if (result && result.success) {
                    setOriginalCode(code);
                    setChatMessages(prev => [...prev, {sender: 'system', text: `ファイル (${editingFilePath}) が正常に更新されました。`}]);
                }
            };

            const handleGoBack = () => {
                if (currentRemotePath === '/') return;
                const pathParts = currentRemotePath.split('/').filter(part => part !== '');
                pathParts.pop();
                const newPath = pathParts.length === 0 ? '/' : `/${pathParts.join('/')}`;
                fetchRemoteFiles(newPath);
            };
            const handleGoHome = () => fetchRemoteFiles('/');
            const handleRefresh = () => fetchRemoteFiles(currentRemotePath);

            const executeRemoteCommand = async (command) => {
                if (!isRemote) return;
                setIsCommandExecuting(true);
                setCommandOutput(prev => prev + `\n[${new Date().toLocaleTimeString()}]> ${command}\n`);
                try {
                    const result = await callBackendApi('/execute', { command });
                    if(result) {
                        setCommandOutput(prev => prev + (result.output || '') + (result.error ? `\nエラー: ${result.error}` : '') + '\n');
                    }
                } finally {
                    setIsCommandExecuting(false);
                    setCommandInput('');
                }
            };

            const callGeminiApi = async (userPrompt, currentChatHistory, currentFullCode, linesToEditInfo) => {
              setIsGeminiLoading(true);
              setError(null);
              
              const payload = {
                userPrompt: userPrompt,
                currentChatHistory: currentChatHistory,
                currentFullCode: currentFullCode,
                linesToEditInfo: linesToEditInfo
              };

              try {
                const response = await fetch(`${BACKENDURL}/gemini`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
                  const errorData = await response.json();
                  throw new Error(`APIエラー: ${errorData.message || response.statusText}`);
                }

                const result = await response.json();
                if (result.success) {
                    return result.responseText;
                } else {
                    throw new Error(result.message || 'バックエンドAPIからエラーが返されました。');
                }
              } catch (e) {
                console.error('Gemini API Call failed via backend:', e);
                setError(e.message || 'バックエンド経由のGemini API呼び出し中にエラーが発生しました。');
                return null;
              } finally {
                setIsGeminiLoading(false);
              }
            };

            const handleSendMessage = async () => {
              if (!userInput.trim()) return;
              const newUserMessage = { sender: 'user', text: userInput };
              setChatMessages(prev => [...prev, newUserMessage]);
              const geminiResponseText = await callGeminiApi(userInput, [...chatMessages, newUserMessage], code, editingContext);
              setUserInput('');
              if (geminiResponseText !== null) {
                const newGeminiMessage = {
                  sender: 'gemini', text: geminiResponseText, isCodeSuggestion: true,
                  editingContextSnapshot: editingContext ? { ...editingContext } : null,
                };
                setChatMessages(prev => [...prev, newGeminiMessage]);
              }
            };
            
            const handleApplyCode = (rawGeminiResponse, messageEditingContextSnapshot) => {
              setCode(rawGeminiResponse); 
              setShowEditorTab(true);
              if (messageEditingContextSnapshot) {
                  setChatMessages(prev => [...prev, {sender: 'system', text: `編集指示に基づき、コード全体が更新されました。エディタタブを確認してください。`}]);
              } else {
                  setChatMessages(prev => [...prev, {sender: 'system', text: '新しいコードがエディタに反映されました。'}]);
              }
              setEditingContext(null);
              setActiveTab('editor');
              setSelectedLines([]);
            };

            const handleEditSelectedLines = () => {
              if (selectedLines.length === 0) return;
              const sortedSelectedLines = [...selectedLines].sort((a, b) => a - b);
              setEditingContext({ lines: sortedSelectedLines });
              setActiveTab('chat');
              setUserInput(''); 
              setChatMessages(prev => [
                  ...prev,
                  {sender: 'system', text: `第${sortedSelectedLines.join(', ')}行付近の編集内容を指示してください。`}
              ]);
            };

            const toggleLineSelection = (lineNumber) => {
              setSelectedLines(prev =>
                prev.includes(lineNumber) ? prev.filter(ln => ln !== lineNumber) : [...prev, lineNumber]
              );
            };

            const toggleAllLinesSelection = () => {
                const allLineNumbers = code.split('\n').map((_, index) => index + 1);
                if (allLinesSelected) {
                    setSelectedLines([]);
                } else {
                    setSelectedLines(allLineNumbers);
                }
                setAllLinesSelected(!allLinesSelected);
            };
            
            const handleAddCustomCommand = () => {
              if (newCustomCommandName.trim() && newCustomCommandValue.trim()) {
                  const newCommands = [...customCommands, { name: newCustomCommandName.trim(), command: newCustomCommandValue.trim() }];
                  setCustomCommands(newCommands);
                  localStorage.setItem('customSshCommands', JSON.stringify(newCommands));
                  setNewCustomCommandName('');
                  setNewCustomCommandValue('');
              }
            };

            const handleDeleteCustomCommand = (indexToDelete) => {
                const updatedCommands = customCommands.filter((_, index) => index !== indexToDelete);
                setCustomCommands(updatedCommands);
                localStorage.setItem('customSshCommands', JSON.stringify(updatedCommands));
            };

            const handleCopyToClipboard = () => {
                if (!code) return;
                navigator.clipboard.writeText(code)
                    .then(() => showNotification("クリップボードにコピーしました！"))
                    .catch(err => {
                        console.error('クリップボードへのコピーに失敗:', err);
                        showNotification("コピーに失敗しました。", true);
                    });
            };
            
            const allTabs = [
                { id: 'files', label: 'ファイル', icon: Folder, remoteOnly: true },
                { id: 'chat', label: 'チャット', icon: MessageSquare },
                { id: 'editor', label: 'エディタ', icon: Edit3, requiresVisible: true },
                { id: 'commands', label: 'コマンド', icon: Terminal, remoteOnly: true },
            ];
            
            const visibleTabs = isRemote 
                ? [allTabs[0], allTabs[1], allTabs[2], allTabs[3]]
                : [allTabs[1], allTabs[2]];

            const renderEditor = () => {
              const isModified = editingFilePath && code !== originalCode;
              // [MODIFIED] h-full を flex-grow に変更し、footerにflex-shrink-0を追加
              return(
                <div className="flex flex-col flex-grow bg-gray-900 text-white">
                    <div className="flex-grow p-4 overflow-auto bg-gray-800">
                        {code.split('\n').map((line, index) => {
                            const lineNumber = index + 1;
                            const isSelected = selectedLines.includes(lineNumber);
                            return (
                                <div key={lineNumber} className={`flex items-center p-1 rounded transition-colors duration-100 ${isSelected ? 'bg-blue-900/60' : 'hover:bg-gray-700/70'}`}>
                                    <div className="mr-3 select-none cursor-pointer" onClick={() => toggleLineSelection(lineNumber)}>
                                        {isSelected ? <CheckSquare size={20} className="text-blue-400" /> : <Square size={20} className="text-gray-600 hover:text-gray-400" />}
                                    </div>
                                    <span className="text-gray-500 mr-4 w-8 text-right select-none">{lineNumber}</span>
                                    <pre className="whitespace-pre-wrap flex-grow text-gray-200 font-mono text-sm">{line || ' '}</pre>
                                </div>
                            );
                        })}
                        {code.length === 0 && (
                            <div className="text-center text-gray-500 mt-12">
                                <p className="text-lg">エディタは空です。</p>
                                <p>チャットでコードを生成するか、リモートファイルを「編集」してください。</p>
                            </div>
                        )}
                    </div>
                    <footer className="p-3 bg-gray-900 border-t border-gray-700 flex justify-between items-center space-x-3 flex-shrink-0">
                        <button onClick={toggleAllLinesSelection} className="font-semibold py-2 px-4 rounded-lg shadow flex items-center transition-all bg-purple-600 hover:bg-purple-700 text-white">
                            {allLinesSelected ? '全選択解除' : '全て選択'}
                        </button>
                        <div className="flex space-x-3">
                          <button onClick={handleEditSelectedLines} disabled={selectedLines.length === 0} className={`font-semibold py-2 px-4 rounded-lg shadow flex items-center transition-all ${selectedLines.length > 0 ? 'bg-yellow-500 hover:bg-yellow-600 text-black' : 'bg-gray-600 text-gray-400 cursor-not-allowed'}`}>
                              <Edit3 size={18} className="mr-1.5" /> 選択行を編集
                          </button>
                          {isRemote ? (
                              <button 
                                  onClick={handleSaveAndUpdate} 
                                  className={`font-semibold py-2 px-4 rounded-lg shadow flex items-center transition-all ${
                                      isModified ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-gray-600 text-gray-400 cursor-not-allowed'
                                  }`}
                                  disabled={!isModified || isBackendLoading || isGeminiLoading}
                              >
                                  <Upload size={18} className="mr-1.5" /> 保存&更新
                              </button>
                          ) : (
                              <button onClick={handleCopyToClipboard} className="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow flex items-center" disabled={!code}>
                                  <Save size={18} className="mr-1.5" /> クリップボードにコピー
                              </button>
                          )}
                        </div>
                    </footer>
                </div>
              );
            }
            
            // [MODIFIED] h-full を flex-grow に変更し、入力欄コンテナに flex-shrink-0 を追加
            const renderChat = () => (
                <div className="flex flex-col flex-grow bg-gray-800 text-white">
                    <div className="flex-grow p-4 overflow-y-auto space-y-4">
                        {chatMessages.map((msg, index) => (
                          <div key={index} className={`flex items-start gap-3 ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
                            {msg.sender !== 'user' && msg.sender !== 'system' && <div className="w-8 h-8 rounded-full bg-gray-600 flex items-center justify-center flex-shrink-0"><Bot size={20} /></div>}
                            <div className={`max-w-2xl p-3 rounded-lg shadow ${
                              msg.sender === 'user' ? 'bg-blue-600' : 
                              msg.sender === 'gemini' ? 'bg-gray-600' : 
                              'bg-yellow-800/50 text-yellow-200 text-sm italic w-full text-center py-2'
                            }`}>
                                <div className="whitespace-pre-wrap">{msg.text}</div>
                                {msg.isCodeSuggestion && (
                                    <button onClick={() => handleApplyCode(msg.text, msg.editingContextSnapshot)} className="mt-3 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-3 rounded-lg text-sm flex items-center">
                                        <CheckSquare size={16} className="mr-1.5" /> エディタに適用
                                    </button>
                                )}
                            </div>
                            {msg.sender === 'user' && <div className="w-8 h-8 rounded-full bg-blue-800 flex items-center justify-center flex-shrink-0"><User size={20} /></div>}
                          </div>
                        ))}
                        {isGeminiLoading && <div className="flex justify-center p-4"><div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-400"></div><p className="ml-3">Geminiが考え中...</p></div>}
                        <div ref={chatEndRef} />
                    </div>
                    <div className="p-4 bg-gray-900 border-t border-gray-700 flex-shrink-0">
                      {editingContext && <div className="text-yellow-400 text-sm mb-2 p-2 bg-yellow-900/50 rounded">編集モード: 第{editingContext.lines.join(', ')}行について指示してください。コード全体が更新されます。</div>}
                        <div className="flex items-center space-x-2">
                            <input type="text" value={userInput} onChange={(e) => setUserInput(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && !isGeminiLoading && handleSendMessage()} placeholder="Geminiにメッセージを送信..." className="flex-grow p-3 bg-gray-700 text-white rounded-lg" disabled={isGeminiLoading} />
                            <button onClick={handleSendMessage} className="bg-blue-500 hover:bg-blue-600 text-white p-3 rounded-lg" disabled={isGeminiLoading || !userInput.trim()}>
                                <Send size={20} />
                            </button>
                        </div>
                    </div>
                </div>
            );

            const renderFileManager = () => (
                <div className="flex flex-col h-full bg-gray-900 text-white">
                    <div className="p-4 bg-gray-800 border-b border-gray-700 flex items-center space-x-2 flex-shrink-0">
                        <button onClick={handleGoBack} disabled={currentRemotePath === '/'} className="p-2 rounded-lg bg-gray-700 hover:bg-gray-600 disabled:opacity-50"><ArrowLeft size={20} /></button>
                        <button onClick={handleGoHome} disabled={currentRemotePath === '/'} className="p-2 rounded-lg bg-gray-700 hover:bg-gray-600 disabled:opacity-50"><Home size={20} /></button>
                        <button onClick={handleRefresh} className="p-2 rounded-lg bg-gray-700 hover:bg-gray-600"><RefreshCw size={20} /></button>
                        <span className="flex-grow text-gray-400 text-sm truncate ml-2">パス: {currentRemotePath}</span>
                    </div>
                    <div className="flex-grow overflow-y-auto p-4 space-y-2">
                        {isBackendLoading ? <div className="text-center text-gray-400">ロード中...</div> : remoteFiles.length === 0 ? <div className="text-center text-gray-500 mt-10">このディレクトリは空です。</div> : (
                            remoteFiles.map((item, index) => (
                                <div key={index} className="flex items-center bg-gray-800 p-3 rounded-lg hover:bg-gray-700/80 cursor-pointer" onClick={() => handleFileItemClick(item)}>
                                    {item.type === 'directory' ? <Folder size={24} className="text-blue-400 mr-3 flex-shrink-0" /> : <FileText size={24} className="text-green-400 mr-3 flex-shrink-0" />}
                                    <span className="flex-grow truncate font-mono text-sm">{item.name}</span>
                                    {item.type === 'file' && (
                                        <button onClick={(e) => { e.stopPropagation(); handleEditFile(item.name); }} className="ml-4 bg-purple-600 hover:bg-purple-700 text-white text-xs px-3 py-1 rounded-md flex items-center flex-shrink-0">
                                            <EditFileIcon size={14} className="mr-1" /> 編集
                                        </button>
                                    )}
                                </div>
                            ))
                        )}
                    </div>
                </div>
            );
            
            const renderCommandExecutor = () => (
                <div className="flex flex-col h-full p-4 overflow-auto bg-gray-900 text-white">
                  <div className="flex flex-col flex-grow">
                    <h2 className="text-lg font-semibold text-gray-200 mb-3 flex items-center flex-shrink-0">
                      <Terminal size={20} className="mr-2 text-teal-400" /> コマンド実行器
                    </h2>
                    <pre ref={commandOutputRef} className="bg-black text-green-400 p-4 rounded-lg shadow-inner overflow-auto h-64 font-mono text-sm mb-4 flex-grow">
                      {commandOutput || 'ここにコマンド出力が表示されます...'}
                    </pre>
                    <div className="flex space-x-2 mb-4 flex-shrink-0">
                      <input type="text" value={commandInput} onChange={(e) => setCommandInput(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && !isCommandExecuting && executeRemoteCommand(commandInput)} placeholder="実行するコマンドを入力" className="flex-grow p-3 bg-gray-700 text-white rounded-lg" disabled={isCommandExecuting} />
                      <button onClick={() => executeRemoteCommand(commandInput)} className="bg-teal-600 hover:bg-teal-700 text-white font-semibold p-3 rounded-lg" disabled={isCommandExecuting || !commandInput.trim()}>実行</button>
                    </div>
                     <div className="flex-shrink-0">
                        <h3 className="text-md font-semibold text-gray-200 mb-2">カスタムコマンド</h3>
                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 mb-3">
                          {customCommands.map((cmd, index) => (
                            <div key={index} className="flex items-center bg-gray-800 p-2 rounded-lg justify-between">
                              <button onClick={() => setCommandInput(cmd.command)} className="flex-grow text-left text-blue-400 hover:text-blue-300 truncate text-sm" title={cmd.command}>{cmd.name}</button>
                              <button onClick={() => handleDeleteCustomCommand(index)} className="ml-2 text-red-500 hover:text-red-400"><Trash2 size={16} /></button>
                            </div>
                          ))}
                        </div>
                        <div className="bg-gray-800 p-3 rounded-lg">
                          <h4 className="text-sm font-semibold mb-2">新しいカスタムコマンド</h4>
                          <div className="space-y-2">
                            <input type="text" value={newCustomCommandName} onChange={(e) => setNewCustomCommandName(e.target.value)} placeholder="名前" className="w-full p-2 bg-gray-700 text-sm rounded-md"/>
                            <input type="text" value={newCustomCommandValue} onChange={(e) => setNewCustomCommandValue(e.target.value)} placeholder="コマンド" className="w-full p-2 bg-gray-700 text-sm rounded-md"/>
                            <button onClick={handleAddCustomCommand} className="w-full bg-green-700 hover:bg-green-600 py-2 text-sm rounded-md" disabled={!newCustomCommandName.trim() || !newCustomCommandValue.trim()}>追加</button>
                          </div>
                        </div>
                    </div>
                  </div>
                </div>
            );

            const renderConnectionModal = () => (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 transition-opacity">
                    <div className="bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-md border border-gray-700">
                        <h2 className="text-3xl font-bold text-white mb-6 text-center flex items-center justify-center"><Server size={32} className="inline mr-3 text-blue-400" /> リモートサーバーに接続</h2>
                        {error && <div className="bg-red-700/30 text-red-300 p-3 rounded-lg mb-4 text-center">{error}</div>}
                        <div className="space-y-4">
                            <input type="text" value={connectionInfo.ip} onChange={e => setConnectionInfo({...connectionInfo, ip: e.target.value})} placeholder="IPアドレス / ホスト名" className="w-full p-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500" />
                            <input type="number" value={connectionInfo.port} onChange={e => setConnectionInfo({...connectionInfo, port: e.target.value})} placeholder="ポート (デフォルト: 22)" className="w-full p-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500" />
                            <input type="text" value={connectionInfo.username} onChange={e => setConnectionInfo({...connectionInfo, username: e.target.value})} placeholder="ユーザー名" className="w-full p-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500" />
                            <input type="password" value={connectionInfo.password} onChange={e => setConnectionInfo({...connectionInfo, password: e.target.value})} placeholder="パスワード" className="w-full p-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500" />
                        </div>
                        <div className="flex justify-end space-x-4 mt-6">
                             <button onClick={() => { setShowConnectionModal(false); setError(null); }} className="py-2 px-4 bg-gray-600 hover:bg-gray-500 rounded-lg font-semibold">キャンセル</button>
                             <button onClick={handleConnect} className="py-2 px-6 bg-blue-600 hover:bg-blue-700 rounded-lg font-semibold" disabled={isBackendLoading}>{isBackendLoading ? '接続中...' : '接続'}</button>
                        </div>
                    </div>
                </div>
            );

            return (
                <div className="min-h-screen w-screen font-sans flex flex-col bg-gray-900 text-white">
                    <header className="p-3 bg-gray-800 shadow-md flex items-center justify-between flex-shrink-0 border-b border-gray-700">
                        <h1 className="text-xl font-semibold flex items-center">
                           <HardDrive size={24} className="mr-3 text-purple-400" />
                           <span className="font-mono text-lg">{isRemote ? `${connectionInfo.username}@${connectionInfo.ip}` : 'ローカル環境'}</span>
                        </h1>
                        <div className="flex items-center">
                          {error && !showConnectionModal && <div className="text-red-400 text-sm mr-4 flex items-center"><AlertTriangle size={16} className="mr-1.5" />{error}</div>}
                          {isRemote ? (
                              <button onClick={handleDisconnect} className="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow">切断</button>
                          ) : (
                              <button onClick={() => { setShowConnectionModal(true); setError(null); }} className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow">リモート接続</button>
                          )}
                        </div>
                    </header>
                    
                    <div className="flex bg-gray-800 border-b border-gray-700 flex-shrink-0">
                        {visibleTabs.filter(tab => {
                            if (tab.remoteOnly && !isRemote) return false;
                            if (tab.requiresVisible && !showEditorTab) return false;
                            return true;
                        }).map(tab => (
                            <button
                              key={tab.id}
                              onClick={() => { setActiveTab(tab.id); setError(null); }}
                              className={`flex-1 py-3 text-center font-semibold transition duration-150 ease-in-out flex items-center justify-center ${activeTab === tab.id ? 'bg-gray-700 text-white border-b-2 border-blue-500' : 'text-gray-400 hover:bg-gray-700/50'}`}
                            >
                               <tab.icon size={18} className="mr-2" /> {tab.label}
                            </button>
                        ))}
                    </div>
                    
                    {/* [MODIFIED] 主内容コンテナに flex と flex-col を追加 */}
                    <div className="flex-grow flex flex-col overflow-hidden bg-gray-800">
                        {activeTab === 'editor' && showEditorTab && renderEditor()}
                        {activeTab === 'chat' && renderChat()}
                        {isRemote && activeTab === 'files' && renderFileManager()}
                        {isRemote && activeTab === 'commands' && renderCommandExecutor()}
                    </div>
                    
                    {showConnectionModal && renderConnectionModal()}

                    {notification && (
                        <div className={`fixed bottom-8 right-8 py-3 px-5 rounded-lg shadow-xl text-white text-sm font-semibold transition-opacity duration-300 ${notification.isError ? 'bg-red-600' : 'bg-blue-600'}`}>
                            {notification.message}
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>